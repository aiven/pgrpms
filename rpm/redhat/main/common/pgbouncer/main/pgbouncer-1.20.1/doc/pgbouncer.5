.\" Automatically generated by Pandoc 2.5
.\"
.TH "PGBOUNCER.INI" "5" "" "1.20.1" "Databases"
.hy
.SH NAME
.PP
pgbouncer.ini \- configuration file for pgbouncer
.SH DESCRIPTION
.PP
The configuration file is in \[lq]ini\[rq] format.
Section names are between \[lq][\[dq] and \[dq]]\[rq].
Lines starting with \[lq];\[rq] or \[lq]#\[rq] are taken as comments and
ignored.
The characters \[lq];\[rq] and \[lq]#\[rq] are not recognized as special
when they appear later in the line.
.SH GENERIC SETTINGS
.SS logfile
.PP
Specifies the log file.
For daemonization (\f[C]\-d\f[R]), either this or \f[C]syslog\f[R] need
to be set.
.PP
The log file is kept open, so after rotation, \f[C]kill \-HUP\f[R] or on
console \f[C]RELOAD;\f[R] should be done.
On Windows, the service must be stopped and started.
.PP
Note that setting \f[C]logfile\f[R] does not by itself turn off logging
to stderr.
Use the command\-line option \f[C]\-q\f[R] or \f[C]\-d\f[R] for that.
.PP
Default: not set
.SS pidfile
.PP
Specifies the PID file.
Without \f[C]pidfile\f[R] set, daemonization (\f[C]\-d\f[R]) is not
allowed.
.PP
Default: not set
.SS listen_addr
.PP
Specifies a list (comma\-separated) of addresses where to listen for TCP
connections.
You may also use \f[C]*\f[R] meaning \[lq]listen on all addresses\[rq].
When not set, only Unix socket connections are accepted.
.PP
Addresses can be specified numerically (IPv4/IPv6) or by name.
.PP
Default: not set
.SS listen_port
.PP
Which port to listen on.
Applies to both TCP and Unix sockets.
.PP
Default: 6432
.SS unix_socket_dir
.PP
Specifies the location for Unix sockets.
Applies to both the listening socket and to server connections.
If set to an empty string, Unix sockets are disabled.
A value that starts with \f[C]\[at]\f[R] specifies that a Unix socket in
the abstract namespace should be created (currently supported on Linux
and Windows).
.PP
For online reboot (\f[C]\-R\f[R]) to work, a Unix socket needs to be
configured, and it needs to be in the file\-system namespace.
.PP
Default: \f[C]/tmp\f[R] (empty on Windows)
.SS unix_socket_mode
.PP
File system mode for Unix socket.
Ignored for sockets in the abstract namespace.
Not supported on Windows.
.PP
Default: 0777
.SS unix_socket_group
.PP
Group name to use for Unix socket.
Ignored for sockets in the abstract namespace.
Not supported on Windows.
.PP
Default: not set
.SS user
.PP
If set, specifies the Unix user to change to after startup.
Works only if PgBouncer is started as root or if it\[cq]s already
running as the given user.
Not supported on Windows.
.PP
Default: not set
.SS pool_mode
.PP
Specifies when a server connection can be reused by other clients.
.TP
.B session
Server is released back to pool after client disconnects.
Default.
.TP
.B transaction
Server is released back to pool after transaction finishes.
.TP
.B statement
Server is released back to pool after query finishes.
Transactions spanning multiple statements are disallowed in this mode.
.SS max_client_conn
.PP
Maximum number of client connections allowed.
.PP
When this setting is increased, then the file descriptor limits in the
operating system might also have to be increased.
Note that the number of file descriptors potentially used is more than
\f[C]max_client_conn\f[R].
If each user connects under its own user name to the server, the
theoretical maximum used is:
.IP
.nf
\f[C]
max_client_conn + (max pool_size * total databases * total users)
\f[R]
.fi
.PP
If a database user is specified in the connection string (all users
connect under the same user name), the theoretical maximum is:
.IP
.nf
\f[C]
max_client_conn + (max pool_size * total databases)
\f[R]
.fi
.PP
The theoretical maximum should never be reached, unless somebody
deliberately crafts a special load for it.
Still, it means you should set the number of file descriptors to a
safely high number.
.PP
Search for \f[C]ulimit\f[R] in your favorite shell man page.
Note: \f[C]ulimit\f[R] does not apply in a Windows environment.
.PP
Default: 100
.SS default_pool_size
.PP
How many server connections to allow per user/database pair.
Can be overridden in the per\-database configuration.
.PP
Default: 20
.SS min_pool_size
.PP
Add more server connections to pool if below this number.
Improves behavior when the normal load suddently comes back after a
period of total inactivity.
The value is effectively capped at the pool size.
.PP
Default: 0 (disabled)
.SS reserve_pool_size
.PP
How many additional connections to allow to a pool (see
\f[C]reserve_pool_timeout\f[R]).
0 disables.
.PP
Default: 0 (disabled)
.SS reserve_pool_timeout
.PP
If a client has not been serviced in this time, use additional
connections from the reserve pool.
0 disables.
[seconds]
.PP
Default: 5.0
.SS max_db_connections
.PP
Do not allow more than this many server connections per database
(regardless of user).
This considers the PgBouncer database that the client has connected to,
not the PostgreSQL database of the outgoing connection.
.PP
This can also be set per database in the \f[C][databases]\f[R] section.
.PP
Note that when you hit the limit, closing a client connection to one
pool will not immediately allow a server connection to be established
for another pool, because the server connection for the first pool is
still open.
Once the server connection closes (due to idle timeout), a new server
connection will immediately be opened for the waiting pool.
.PP
Default: 0 (unlimited)
.SS max_user_connections
.PP
Do not allow more than this many server connections per user (regardless
of database).
This considers the PgBouncer user that is associated with a pool, which
is either the user specified for the server connection or in absence of
that the user the client has connected as.
.PP
This can also be set per user in the \f[C][users]\f[R] section.
.PP
Note that when you hit the limit, closing a client connection to one
pool will not immediately allow a server connection to be established
for another pool, because the server connection for the first pool is
still open.
Once the server connection closes (due to idle timeout), a new server
connection will immediately be opened for the waiting pool.
.PP
Default: 0 (unlimited)
.SS server_round_robin
.PP
By default, PgBouncer reuses server connections in LIFO (last\-in,
first\-out) manner, so that few connections get the most load.
This gives best performance if you have a single server serving a
database.
But if there is a round\-robin system behind a database address (TCP,
DNS, or host list), then it is better if PgBouncer also uses connections
in that manner, thus achieving uniform load.
.PP
Default: 0
.SS track_extra_parameters
.PP
By default, PgBouncer tracks \f[C]client_encoding\f[R],
\f[C]datestyle\f[R], \f[C]timezone\f[R],
\f[C]standard_conforming_strings\f[R] and \f[C]application_name\f[R]
parameters per client.
To allow other parameters to be tracked, they can be specified here, so
that PgBouncer knows that they should be maintained in the client
variable cache and restored in the server whenever the client becomes
active.
.PP
If you need to specify multiple values, use a comma\-separated list
(e.g.
\f[C]default_transaction_readonly, IntervalStyle\f[R])
.PP
Note: Most parameters cannot be tracked this way.
The only parameters that can be tracked are ones that Postgres reports
to the client.
Postgres has an official list of parameters that it reports to the
client (https://www.postgresql.org/docs/15/protocol-flow.html#PROTOCOL-ASYNC).
Postgres extensions can change this list though, they can add parameters
themselves that they also report, and they can start reporting already
existing paremeters that Postgres does not report.
Notably Citus 12.0+ causes Postgres to also report
\f[C]search_path\f[R].
.PP
The postgres protocol allows specifying parameters settings, both
direcly as a parameter in the startup packet, or inside the
\f[C]options\f[R] startup
packet (https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-OPTIONS).
Parameters specified using both of these methods are supported by
\f[C]track_extra_parameters\f[R].
However, it\[cq]s not possible to include \f[C]options\f[R] itself in
\f[C]track_extra_parameters\f[R], only the parameters contained in
\f[C]options\f[R].
.PP
Default: IntervalStyle
.SS ignore_startup_parameters
.PP
By default, PgBouncer allows only parameters it can keep track of in
startup packets: \f[C]client_encoding\f[R], \f[C]datestyle\f[R],
\f[C]timezone\f[R] and \f[C]standard_conforming_strings\f[R].
All others parameters will raise an error.
To allow others parameters, they can be specified here, so that
PgBouncer knows that they are handled by the admin and it can ignore
them.
.PP
If you need to specify multiple values, use a comma\-separated list
(e.g.
\f[C]options,extra_float_digits\f[R])
.PP
The postgres protocol allows specifying parameters settings, both
direcly as a parameter in the startup packet, or inside the
\f[C]options\f[R] startup
packet (https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNECT-OPTIONS).
Parameters specified using both of these methods are supported by
\f[C]ignore_startup_parameters\f[R].
It\[cq]s even possible to include \f[C]options\f[R] itself in
\f[C]track_extra_parameters\f[R], which results in any unkown parameters
contained inside \f[C]options\f[R] to be ignored.
.PP
Default: empty
.SS peer_id
.PP
The peer id used to identify this PgBouncer process in a group of
PgBouncer processes that are peered together.
The \f[C]peer_id\f[R] value should be unique within a group of peered
PgBouncer processes.
When set to 0 pgbouncer peering is disabled.
See the docs for the \f[C][peers]\f[R] section for more information.
The maximum value that can be used for the \f[C]peer_id\f[R] is 16383.
.PP
Default: 0
.SS disable_pqexec
.PP
Disable the Simple Query protocol (PQexec).
Unlike the Extended Query protocol, Simple Query allows multiple queries
in one packet, which allows some classes of SQL\-injection attacks.
Disabling it can improve security.
Obviously, this means only clients that exclusively use the Extended
Query protocol will stay working.
.PP
Default: 0
.SS application_name_add_host
.PP
Add the client host address and port to the application name setting set
on connection start.
This helps in identifying the source of bad queries etc.
This logic applies only at the start of a connection.
If \f[C]application_name\f[R] is later changed with \f[C]SET\f[R],
PgBouncer does not change it again.
.PP
Default: 0
.SS conffile
.PP
Show location of current config file.
Changing it will make PgBouncer use another config file for next
\f[C]RELOAD\f[R] / \f[C]SIGHUP\f[R].
.PP
Default: file from command line
.SS service_name
.PP
Used on win32 service registration.
.PP
Default: \f[C]pgbouncer\f[R]
.SS job_name
.PP
Alias for \f[C]service_name\f[R].
.SS stats_period
.PP
Sets how often the averages shown in various \f[C]SHOW\f[R] commands are
updated and how often aggregated statistics are written to the log (but
see \f[C]log_stats\f[R]).
[seconds]
.PP
Default: 60
.SH AUTHENTICATION SETTINGS
.PP
PgBouncer handles its own client authentication and has its own database
of users.
These settings control this.
.SS auth_type
.PP
How to authenticate users.
.TP
.B cert
Client must connect over TLS connection with a valid client certificate.
The user name is then taken from the CommonName field from the
certificate.
.TP
.B md5
Use MD5\-based password check.
This is the default authentication method.
\f[C]auth_file\f[R] may contain both MD5\-encrypted and plain\-text
passwords.
If \f[C]md5\f[R] is configured and a user has a SCRAM secret, then SCRAM
authentication is used automatically instead.
.TP
.B scram\-sha\-256
Use password check with SCRAM\-SHA\-256.
\f[C]auth_file\f[R] has to contain SCRAM secrets or plain\-text
passwords.
.TP
.B plain
The clear\-text password is sent over the wire.
Deprecated.
.TP
.B trust
No authentication is done.
The user name must still exist in \f[C]auth_file\f[R].
.TP
.B any
Like the \f[C]trust\f[R] method, but the user name given is ignored.
Requires that all databases are configured to log in as a specific user.
Additionally, the console database allows any user to log in as admin.
.TP
.B hba
The actual authentication type is loaded from \f[C]auth_hba_file\f[R].
This allows different authentication methods for different access paths,
for example: connections over Unix socket use the \f[C]peer\f[R] auth
method, connections over TCP must use TLS.
.TP
.B pam
PAM is used to authenticate users, \f[C]auth_file\f[R] is ignored.
This method is not compatible with databases using the
\f[C]auth_user\f[R] option.
The service name reported to PAM is \[lq]pgbouncer\[rq].
\f[C]pam\f[R] is not supported in the HBA configuration file.
.SS auth_hba_file
.PP
HBA configuration file to use when \f[C]auth_type\f[R] is \f[C]hba\f[R].
.PP
Default: not set
.SS auth_file
.PP
The name of the file to load user names and passwords from.
See section Authentication file format below about details.
.PP
Most authentication types (see above) require that either
\f[C]auth_file\f[R] or \f[C]auth_user\f[R] be set; otherwise there would
be no users defined.
.PP
Default: not set
.SS auth_user
.PP
If \f[C]auth_user\f[R] is set, then any user not specified in
\f[C]auth_file\f[R] will be queried through the \f[C]auth_query\f[R]
query from pg_shadow in the database, using \f[C]auth_user\f[R].
The password of \f[C]auth_user\f[R] will be taken from
\f[C]auth_file\f[R].
(If the \f[C]auth_user\f[R] does not require a password then it does not
need to be defined in \f[C]auth_file\f[R].)
.PP
Direct access to pg_shadow requires admin rights.
It\[cq]s preferable to use a non\-superuser that calls a SECURITY
DEFINER function instead.
.PP
Default: not set
.SS auth_query
.PP
Query to load user\[cq]s password from database.
.PP
Direct access to pg_shadow requires admin rights.
It\[cq]s preferable to use a non\-superuser that calls a SECURITY
DEFINER function instead.
.PP
Note that the query is run inside the target database.
So if a function is used, it needs to be installed into each database.
.PP
Default:
\f[C]SELECT usename, passwd FROM pg_shadow WHERE usename=$1\f[R]
.SS auth_dbname
.PP
Database name in the \f[C][database]\f[R] section to be used for
authentication purposes.
This option can be either global or overriden in the connection string
if this parameter is specified.
.SH LOG SETTINGS
.SS syslog
.PP
Toggles syslog on/off.
On Windows, the event log is used instead.
.PP
Default: 0
.SS syslog_ident
.PP
Under what name to send logs to syslog.
.PP
Default: \f[C]pgbouncer\f[R] (program name)
.SS syslog_facility
.PP
Under what facility to send logs to syslog.
Possibilities: \f[C]auth\f[R], \f[C]authpriv\f[R], \f[C]daemon\f[R],
\f[C]user\f[R], \f[C]local0\-7\f[R].
.PP
Default: \f[C]daemon\f[R]
.SS log_connections
.PP
Log successful logins.
.PP
Default: 1
.SS log_disconnections
.PP
Log disconnections with reasons.
.PP
Default: 1
.SS log_pooler_errors
.PP
Log error messages the pooler sends to clients.
.PP
Default: 1
.SS log_stats
.PP
Write aggregated statistics into the log, every \f[C]stats_period\f[R].
This can be disabled if external monitoring tools are used to grab the
same data from \f[C]SHOW\f[R] commands.
.PP
Default: 1
.SS verbose
.PP
Increase verbosity.
Mirrors the \[lq]\-v\[rq] switch on the command line.
For example, using \[lq]\-v \-v\[rq] on the command line is the same as
\f[C]verbose=2\f[R].
.PP
Default: 0
.SH CONSOLE ACCESS CONTROL
.SS admin_users
.PP
Comma\-separated list of database users that are allowed to connect and
run all commands on the console.
Ignored when \f[C]auth_type\f[R] is \f[C]any\f[R], in which case any
user name is allowed in as admin.
.PP
Default: empty
.SS stats_users
.PP
Comma\-separated list of database users that are allowed to connect and
run read\-only queries on the console.
That means all \f[C]SHOW\f[R] commands except \f[C]SHOW FDS\f[R].
.PP
Default: empty
.SH CONNECTION SANITY CHECKS, TIMEOUTS
.SS server_reset_query
.PP
Query sent to server on connection release, before making it available
to other clients.
At that moment no transaction is in progress, so the value should not
include \f[C]ABORT\f[R] or \f[C]ROLLBACK\f[R].
.PP
The query is supposed to clean any changes made to the database session
so that the next client gets the connection in a well\-defined state.
The default is \f[C]DISCARD ALL\f[R], which cleans everything, but that
leaves the next client no pre\-cached state.
It can be made lighter, e.g.\ \f[C]DEALLOCATE ALL\f[R] to just drop
prepared statements, if the application does not break when some state
is kept around.
.PP
When transaction pooling is used, the \f[C]server_reset_query\f[R] is
not used, because in that mode, clients must not use any session\-based
features, since each transaction ends up in a different connection and
thus gets a different session state.
.PP
Default: \f[C]DISCARD ALL\f[R]
.SS server_reset_query_always
.PP
Whether \f[C]server_reset_query\f[R] should be run in all pooling modes.
When this setting is off (default), the \f[C]server_reset_query\f[R]
will be run only in pools that are in sessions\-pooling mode.
Connections in transaction\-pooling mode should not have any need for a
reset query.
.PP
This setting is for working around broken setups that run applications
that use session features over a transaction\-pooled PgBouncer.
It changes non\-deterministic breakage to deterministic breakage:
Clients always lose their state after each transaction.
.PP
Default: 0
.SS server_check_delay
.PP
How long to keep released connections available for immediate re\-use,
without running \f[C]server_check_query\f[R] on it.
If 0 then the check is always run.
.PP
Default: 30.0
.SS server_check_query
.PP
Simple do\-nothing query to check if the server connection is alive.
.PP
If an empty string, then sanity checking is disabled.
.PP
Default: \f[C]select 1\f[R]
.SS server_fast_close
.PP
Disconnect a server in session pooling mode immediately or after the end
of the current transaction if it is in \[lq]close_needed\[rq] mode (set
by \f[C]RECONNECT\f[R], \f[C]RELOAD\f[R] that changes connection
settings, or DNS change), rather than waiting for the session end.
In statement or transaction pooling mode, this has no effect since that
is the default behavior there.
.PP
If because of this setting a server connection is closed before the end
of the client session, the client connection is also closed.
This ensures that the client notices that the session has been
interrupted.
.PP
This setting makes connection configuration changes take effect sooner
if session pooling and long\-running sessions are used.
The downside is that client sessions are liable to be interrupted by a
configuration change, so client applications will need logic to
reconnect and reestablish session state.
But note that no transactions will be lost, because running transactions
are not interrupted, only idle sessions.
.PP
Default: 0
.SS server_lifetime
.PP
The pooler will close an unused (not currently linked to any client
connection) server connection that has been connected longer than this.
Setting it to 0 means the connection is to be used only once, then
closed.
[seconds]
.PP
Default: 3600.0
.SS server_idle_timeout
.PP
If a server connection has been idle more than this many seconds it will
be closed.
If 0 then this timeout is disabled.
[seconds]
.PP
Default: 600.0
.SS server_connect_timeout
.PP
If connection and login don\[cq]t finish in this amount of time, the
connection will be closed.
[seconds]
.PP
Default: 15.0
.SS server_login_retry
.PP
If login to the server failed, because of failure to connect or from
authentication, the pooler waits this much before retrying to connect.
During the waiting interval, new clients trying to connect to the
failing server will get an error immediately without another connection
attempt.
[seconds]
.PP
The purpose of this behavior is that clients don\[cq]t unnecessarily
queue up waiting for a server connection to become available if the
server is not working.
However, it also means that if a server is momentarily failing, for
example during a restart or if the configuration was erroneous, then it
will take at least this long until the pooler will consider connecting
to it again.
Planned events such as restarts should normally be managed using the
\f[C]PAUSE\f[R] command to avoid this.
.PP
Default: 15.0
.SS client_login_timeout
.PP
If a client connects but does not manage to log in in this amount of
time, it will be disconnected.
Mainly needed to avoid dead connections stalling \f[C]SUSPEND\f[R] and
thus online restart.
[seconds]
.PP
Default: 60.0
.SS autodb_idle_timeout
.PP
If the automatically created (via \[dq]*\[dq]) database pools have been
unused this many seconds, they are freed.
The negative aspect of that is that their statistics are also forgotten.
[seconds]
.PP
Default: 3600.0
.SS dns_max_ttl
.PP
How long DNS lookups can be cached.
The actual DNS TTL is ignored.
[seconds]
.PP
Default: 15.0
.SS dns_nxdomain_ttl
.PP
How long DNS errors and NXDOMAIN DNS lookups can be cached.
[seconds]
.PP
Default: 15.0
.SS dns_zone_check_period
.PP
Period to check if a zone serial has changed.
.PP
PgBouncer can collect DNS zones from host names (everything after first
dot) and then periodically check if the zone serial changes.
If it notices changes, all host names under that zone are looked up
again.
If any host IP changes, its connections are invalidated.
.PP
Works only with UDNS and c\-ares backends (\f[C]configure\f[R] option
\f[C]\-\-with\-udns\f[R] or \f[C]\-\-with\-cares\f[R]).
.PP
Default: 0.0 (disabled)
.SS resolv_conf
.PP
The location of a custom \f[C]resolv.conf\f[R] file.
This is to allow specifying custom DNS servers and perhaps other name
resolution options, independent of the global operating system
configuration.
.PP
Requires evdns (>= 2.0.3) or c\-ares (>= 1.15.0) backend.
.PP
The parsing of the file is done by the DNS backend library, not
PgBouncer, so see the library\[cq]s documentation for details on allowed
syntax and directives.
.PP
Default: empty (use operating system defaults)
.SH TLS SETTINGS
.SS client_tls_sslmode
.PP
TLS mode to use for connections from clients.
TLS connections are disabled by default.
When enabled, \f[C]client_tls_key_file\f[R] and
\f[C]client_tls_cert_file\f[R] must be also configured to set up the key
and certificate PgBouncer uses to accept client connections.
.TP
.B disable
Plain TCP.
If client requests TLS, it\[cq]s ignored.
Default.
.TP
.B allow
If client requests TLS, it is used.
If not, plain TCP is used.
If the client presents a client certificate, it is not validated.
.TP
.B prefer
Same as \f[C]allow\f[R].
.TP
.B require
Client must use TLS.
If not, the client connection is rejected.
If the client presents a client certificate, it is not validated.
.TP
.B verify\-ca
Client must use TLS with valid client certificate.
.TP
.B verify\-full
Same as \f[C]verify\-ca\f[R].
.SS client_tls_key_file
.PP
Private key for PgBouncer to accept client connections.
.PP
Default: not set
.SS client_tls_cert_file
.PP
Certificate for private key.
Clients can validate it.
.PP
Default: not set
.SS client_tls_ca_file
.PP
Root certificate file to validate client certificates.
.PP
Default: not set
.SS client_tls_protocols
.PP
Which TLS protocol versions are allowed.
Allowed values: \f[C]tlsv1.0\f[R], \f[C]tlsv1.1\f[R], \f[C]tlsv1.2\f[R],
\f[C]tlsv1.3\f[R].
Shortcuts: \f[C]all\f[R] (tlsv1.0,tlsv1.1,tlsv1.2,tlsv1.3),
\f[C]secure\f[R] (tlsv1.2,tlsv1.3), \f[C]legacy\f[R] (all).
.PP
Default: \f[C]secure\f[R]
.SS client_tls_ciphers
.PP
Allowed TLS ciphers, in OpenSSL syntax.
Shortcuts: \f[C]default\f[R]/\f[C]secure\f[R],
\f[C]compat\f[R]/\f[C]legacy\f[R], \f[C]insecure\f[R]/\f[C]all\f[R],
\f[C]normal\f[R], \f[C]fast\f[R].
.PP
Only connections using TLS version 1.2 and lower are affected.
There is currently no setting that controls the cipher choices used by
TLS version 1.3 connections.
.PP
Default: \f[C]fast\f[R]
.SS client_tls_ecdhcurve
.PP
Elliptic Curve name to use for ECDH key exchanges.
.PP
Allowed values: \f[C]none\f[R] (DH is disabled), \f[C]auto\f[R]
(256\-bit ECDH), curve name
.PP
Default: \f[C]auto\f[R]
.SS client_tls_dheparams
.PP
DHE key exchange type.
.PP
Allowed values: \f[C]none\f[R] (DH is disabled), \f[C]auto\f[R]
(2048\-bit DH), \f[C]legacy\f[R] (1024\-bit DH)
.PP
Default: \f[C]auto\f[R]
.SS server_tls_sslmode
.PP
TLS mode to use for connections to PostgreSQL servers.
The default mode is \f[C]prefer\f[R].
.TP
.B disable
Plain TCP.
TLS is not even requested from the server.
.TP
.B allow
FIXME: if server rejects plain, try TLS?
.TP
.B prefer
TLS connection is always requested first from PostgreSQL.
If refused, the connection will be established over plain TCP.
Server certificate is not validated.
Default
.TP
.B require
Connection must go over TLS.
If server rejects it, plain TCP is not attempted.
Server certificate is not validated.
.TP
.B verify\-ca
Connection must go over TLS and server certificate must be valid
according to \f[C]server_tls_ca_file\f[R].
Server host name is not checked against certificate.
.TP
.B verify\-full
Connection must go over TLS and server certificate must be valid
according to \f[C]server_tls_ca_file\f[R].
Server host name must match certificate information.
.SS server_tls_ca_file
.PP
Root certificate file to validate PostgreSQL server certificates.
.PP
Default: not set
.SS server_tls_key_file
.PP
Private key for PgBouncer to authenticate against PostgreSQL server.
.PP
Default: not set
.SS server_tls_cert_file
.PP
Certificate for private key.
PostgreSQL server can validate it.
.PP
Default: not set
.SS server_tls_protocols
.PP
Which TLS protocol versions are allowed.
Allowed values: \f[C]tlsv1.0\f[R], \f[C]tlsv1.1\f[R], \f[C]tlsv1.2\f[R],
\f[C]tlsv1.3\f[R].
Shortcuts: \f[C]all\f[R] (tlsv1.0,tlsv1.1,tlsv1.2,tlsv1.3),
\f[C]secure\f[R] (tlsv1.2,tlsv1.3), \f[C]legacy\f[R] (all).
.PP
Default: \f[C]secure\f[R]
.SS server_tls_ciphers
.PP
Allowed TLS ciphers, in OpenSSL syntax.
Shortcuts: \f[C]default\f[R]/\f[C]secure\f[R],
\f[C]compat\f[R]/\f[C]legacy\f[R], \f[C]insecure\f[R]/\f[C]all\f[R],
\f[C]normal\f[R], \f[C]fast\f[R].
.PP
Only connections using TLS version 1.2 and lower are affected.
There is currently no setting that controls the cipher choices used by
TLS version 1.3 connections.
.PP
Default: \f[C]fast\f[R]
.SH DANGEROUS TIMEOUTS
.PP
Setting the following timeouts can cause unexpected errors.
.SS query_timeout
.PP
Queries running longer than that are canceled.
This should be used only with a slightly smaller server\-side
\f[C]statement_timeout\f[R], to apply only for network problems.
[seconds]
.PP
Default: 0.0 (disabled)
.SS query_wait_timeout
.PP
Maximum time queries are allowed to spend waiting for execution.
If the query is not assigned to a server during that time, the client is
disconnected.
0 disables.
If this is disabled, clients will be queued indefinitely.
[seconds]
.PP
This setting is used to prevent unresponsive servers from grabbing up
connections.
It also helps when the server is down or rejects connections for any
reason.
.PP
Default: 120.0
.SS cancel_wait_timeout
.PP
Maximum time cancellation requests are allowed to spend waiting for
execution.
If the cancel request is not assigned to a server during that time, the
client is disconnected.
0 disables.
If this is disabled, cancel requests will be queued indefinitely.
[seconds]
.PP
This setting is used to prevent a client locking up when a cancel cannot
be forwarded due to the server being down.
.PP
Default: 10.0
.SS client_idle_timeout
.PP
Client connections idling longer than this many seconds are closed.
This should be larger than the client\-side connection lifetime
settings, and only used for network problems.
[seconds]
.PP
Default: 0.0 (disabled)
.SS idle_transaction_timeout
.PP
If a client has been in \[lq]idle in transaction\[rq] state longer, it
will be disconnected.
[seconds]
.PP
Default: 0.0 (disabled)
.SS suspend_timeout
.PP
How long to wait for buffer flush during \f[C]SUSPEND\f[R] or reboot
(\f[C]\-R\f[R]).
A connection is dropped if the flush does not succeed.
[seconds]
.PP
Default: 10
.SH LOW\-LEVEL NETWORK SETTINGS
.SS pkt_buf
.PP
Internal buffer size for packets.
Affects size of TCP packets sent and general memory usage.
Actual libpq packets can be larger than this, so no need to set it
large.
.PP
Default: 4096
.SS max_packet_size
.PP
Maximum size for PostgreSQL packets that PgBouncer allows through.
One packet is either one query or one result set row.
The full result set can be larger.
.PP
Default: 2147483647
.SS listen_backlog
.PP
Backlog argument for listen(2).
Determines how many new unanswered connection attempts are kept in the
queue.
When the queue is full, further new connections are dropped.
.PP
Default: 128
.SS sbuf_loopcnt
.PP
How many times to process data on one connection, before proceeding.
Without this limit, one connection with a big result set can stall
PgBouncer for a long time.
One loop processes one \f[C]pkt_buf\f[R] amount of data.
0 means no limit.
.PP
Default: 5
.SS so_reuseport
.PP
Specifies whether to set the socket option \f[C]SO_REUSEPORT\f[R] on TCP
listening sockets.
On some operating systems, this allows running multiple PgBouncer
instances on the same host listening on the same port and having the
kernel distribute the connections automatically.
This option is a way to get PgBouncer to use more CPU cores.
(PgBouncer is single\-threaded and uses one CPU core per instance.)
.PP
The behavior in detail depends on the operating system kernel.
As of this writing, this setting has the desired effect on (sufficiently
recent versions of) Linux, DragonFlyBSD, and FreeBSD.
(On FreeBSD, it applies the socket option \f[C]SO_REUSEPORT_LB\f[R]
instead.) Some other operating systems support the socket option but it
won\[cq]t have the desired effect: It will allow multiple processes to
bind to the same port but only one of them will get the connections.
See your operating system\[cq]s setsockopt() documentation for details.
.PP
On systems that don\[cq]t support the socket option at all, turning this
setting on will result in an error.
.PP
Each PgBouncer instance on the same host needs different settings for at
least \f[C]unix_socket_dir\f[R] and \f[C]pidfile\f[R], as well as
\f[C]logfile\f[R] if that is used.
Also note that if you make use of this option, you can no longer connect
to a specific PgBouncer instance via TCP/IP, which might have
implications for monitoring and metrics collection.
.PP
To make sure query cancellations keep working, you should set up
PgBouncer peering between the different PgBouncer processes.
For details look at docs for the \f[C]peer_id\f[R] configuration option
and the \f[C]peers\f[R] configuration section.
There\[cq]s also an example that uses peering and so_reuseport in the
example section of these docs.
.PP
Default: 0
.SS tcp_defer_accept
.PP
Sets the \f[C]TCP_DEFER_ACCEPT\f[R] socket option; see
\f[C]man 7 tcp\f[R] for details.
(This is a Boolean option: 1 means enabled.
The actual value set if enabled is currently hardcoded to 45 seconds.)
.PP
This is currently only supported on Linux.
.PP
Default: 1 on Linux, otherwise 0
.SS tcp_socket_buffer
.PP
Default: not set
.SS tcp_keepalive
.PP
Turns on basic keepalive with OS defaults.
.PP
On Linux, the system defaults are tcp_keepidle=7200, tcp_keepintvl=75,
tcp_keepcnt=9.
They are probably similar on other operating systems.
.PP
Default: 1
.SS tcp_keepcnt
.PP
Default: not set
.SS tcp_keepidle
.PP
Default: not set
.SS tcp_keepintvl
.PP
Default: not set
.SS tcp_user_timeout
.PP
Sets the \f[C]TCP_USER_TIMEOUT\f[R] socket option.
This specifies the maximum amount of time in milliseconds that
transmitted data may remain unacknowledged before the TCP connection is
forcibly closed.
If set to 0, then operating system\[cq]s default is used.
.PP
This is currently only supported on Linux.
.PP
Default: 0
.SH SECTION [DATABASES]
.PP
The section \f[C][databases]\f[R] defines the names of the databases
that clients of PgBouncer can connect to and specifies where those
connections will be routed.
The section contains key=value lines like
.IP
.nf
\f[C]
dbname = connection string
\f[R]
.fi
.PP
where the key will be taken as a database name and the value as a
connection string, consisting of key=value pairs of connection
parameters, described below (similar to libpq, but the actual libpq is
not used and the set of available features is different).
Example:
.IP
.nf
\f[C]
foodb = host=host1.example.com port=5432
bardb = host=localhost dbname=bazdb
\f[R]
.fi
.PP
The database name can contain characters \f[C]_0\-9A\-Za\-z\f[R] without
quoting.
Names that contain other characters need to be quoted with standard SQL
identifier quoting: double quotes, with \[dq]\[dq] for a single instance
of a double quote.
.PP
The database name \[lq]pgbouncer\[rq] is reserved for the admin console
and cannot be used as a key here.
.PP
\[dq]*\[dq] acts as a fallback database: If the exact name does not
exist, its value is taken as connection string for the requested
database.
For example, if there is an entry (and no other overriding entries)
.IP
.nf
\f[C]
* = host=foo
\f[R]
.fi
.PP
then a connection to PgBouncer specifying a database \[lq]bar\[rq] will
effectively behave as if an entry
.IP
.nf
\f[C]
bar = host=foo dbname=bar
\f[R]
.fi
.PP
exists (taking advantage of the default for \f[C]dbname\f[R] being the
client\-side database name; see below).
.PP
Such automatically created database entries are cleaned up if they stay
idle longer than the time specified by the \f[C]autodb_idle_timeout\f[R]
parameter.
.SS dbname
.PP
Destination database name.
.PP
Default: same as client\-side database name
.SS host
.PP
Host name or IP address to connect to.
Host names are resolved at connection time, the result is cached per
\f[C]dns_max_ttl\f[R] parameter.
When a host name\[cq]s resolution changes, existing server connections
are automatically closed when they are released (according to the
pooling mode), and new server connections immediately use the new
resolution.
If DNS returns several results, they are used in a round\-robin manner.
.PP
If the value begins with \f[C]/\f[R], then a Unix socket in the
file\-system namespace is used.
If the value begins with \f[C]\[at]\f[R], then a Unix socket in the
abstract namespace is used.
.PP
A comma\-separated list of host names or addresses can be specified.
In that case, connections are made in a round\-robin manner.
(If a host list contains host names that in turn resolve via DNS to
multiple addresses, the round\-robin systems operate independently.
This is an implementation dependency that is subject to change.) Note
that in a list, all hosts must be available at all times: There are no
mechanisms to skip unreachable hosts or to select only available hosts
from a list or similar.
(This is different from what a host list in libpq means.) Also note that
this only affects how the destinations of new connections are chosen.
See also the setting \f[C]server_round_robin\f[R] for how clients are
assigned to already established server connections.
.PP
Examples:
.IP
.nf
\f[C]
host=localhost
host=127.0.0.1
host=2001:0db8:85a3:0000:0000:8a2e:0370:7334
host=/var/run/postgresql
host=192.168.0.1,192.168.0.2,192.168.0.3
\f[R]
.fi
.PP
Default: not set, meaning to use a Unix socket
.SS port
.PP
Default: 5432
.SS user
.PP
If \f[C]user=\f[R] is set, all connections to the destination database
will be done with the specified user, meaning that there will be only
one pool for this database.
.PP
Otherwise, PgBouncer logs into the destination database with the client
user name, meaning that there will be one pool per user.
.SS password
.PP
If no password is specified here, the password from the
\f[C]auth_file\f[R] or \f[C]auth_query\f[R] will be used.
.SS auth_user
.PP
Override of the global \f[C]auth_user\f[R] setting, if specified.
.SS pool_size
.PP
Set the maximum size of pools for this database.
If not set, the \f[C]default_pool_size\f[R] is used.
.SS min_pool_size
.PP
Set the minimum pool size for this database.
If not set, the global \f[C]min_pool_size\f[R] is used.
.SS reserve_pool
.PP
Set additional connections for this database.
If not set, \f[C]reserve_pool_size\f[R] is used.
.SS connect_query
.PP
Query to be executed after a connection is established, but before
allowing the connection to be used by any clients.
If the query raises errors, they are logged but ignored otherwise.
.SS pool_mode
.PP
Set the pool mode specific to this database.
If not set, the default \f[C]pool_mode\f[R] is used.
.SS max_db_connections
.PP
Configure a database\-wide maximum (i.e.\ all pools within the database
will not have more than this many server connections).
.SS client_encoding
.PP
Ask specific \f[C]client_encoding\f[R] from server.
.SS datestyle
.PP
Ask specific \f[C]datestyle\f[R] from server.
.SS timezone
.PP
Ask specific \f[C]timezone\f[R] from server.
.SH SECTION [USERS]
.PP
This section contains key=value lines like
.IP
.nf
\f[C]
user1 = settings
\f[R]
.fi
.PP
where the key will be taken as a user name and the value as a list of
key=value pairs of configuration settings specific for this user.
Example:
.IP
.nf
\f[C]
user1 = pool_mode=session
\f[R]
.fi
.PP
Only a few settings are available here.
.SS pool_mode
.PP
Set the pool mode to be used for all connections from this user.
If not set, the database or default \f[C]pool_mode\f[R] is used.
.SS max_user_connections
.PP
Configure a maximum for the user (i.e.\ all pools with the user will not
have more than this many server connections).
.SH SECTION [PEERS]
.PP
The section \f[C][peers]\f[R] defines the peers that PgBouncer can
forward cancellation requests to and where those cancellation requests
will be routed.
.PP
PgBouncer processes can be peered together in a group by defining a
\f[C]peer_id\f[R] value and a \f[C][peers]\f[R] section in the configs
of all the PgBouncer processes.
These PgBouncer processes can then forward cancellations requests to the
process that it originated from.
This is needed to make cancellations work when multiple PgBouncer
processes (possibly on different servers) are behind the same TCP load
balancer.
Cancellation requests are sent over different TCP connections than the
query they are cancelling, so a TCP load balancer might send the
cancellation request connection to a different process than the one that
it was meant for.
By peering them these cancellation requests eventually end up at the
right process.
A more in\-depth explanation is provided in this recording of a
conference talk (https://www.youtube.com/watch?v=M585FfbboNA).
.PP
The section contains key=value lines like
.IP
.nf
\f[C]
peer_id = connection string
\f[R]
.fi
.PP
Where the key will be taken as a \f[C]peer_id\f[R] and the value as a
connection string, consisting of key=value pairs of connection
parameters, described below (similar to libpq, but the actual libpq is
not used and the set of available features is different).
Example:
.IP
.nf
\f[C]
1 = host=host1.example.com
2 = host=/tmp/pgbouncer\-2  port=5555
\f[R]
.fi
.PP
Note: For peering to work, the \f[C]peer_id\f[R] of each PgBouncer
process in the group must be unique within the peered group.
And the \f[C][peers]\f[R] section should contain entries for each of
those peer ids.
An example can be found in the examples section of these docs.
It \f[B]is\f[R] allowed, but not necessary, for the \f[C][peers]\f[R]
section to contain the \f[C]peer_id\f[R] of the PgBouncer that the
config is for.
Such an entry will be ignored, but it is allowed to config management
easy.
Because it allows using the exact same \f[C][peers]\f[R] section for
multiple configs.
.SS host
.PP
Host name or IP address to connect to.
Host names are resolved at connection time, the result is cached per
\f[C]dns_max_ttl\f[R] parameter.
If DNS returns several results, they are used in a round\-robin manner.
But in general it\[cq]s not recommended to use a hostname that resolves
to multiple IPs, because then the cancel request might still be
forwarded to the wrong node and it would need to be forwarded again
(which is only allowed up to three times).
.PP
If the value begins with \f[C]/\f[R], then a Unix socket in the
file\-system namespace is used.
If the value begins with \f[C]\[at]\f[R], then a Unix socket in the
abstract namespace is used.
.PP
Examples:
.IP
.nf
\f[C]
host=localhost
host=127.0.0.1
host=2001:0db8:85a3:0000:0000:8a2e:0370:7334
host=/var/run/pgbouncer\-1
\f[R]
.fi
.SS port
.PP
Default: 6432
.SS pool_size
.PP
Set the maximum number of cancel requests that can be in flight to the
peer at the same time.
It\[cq]s quite normal for cancel requests to arrive in bursts, e.g.
when the backing Postgres server slow or down.
So it\[cq]s important for \f[C]pool_size\f[R] to not be so low that it
cannot handle these bursts.
.PP
If not set, the \f[C]default_pool_size\f[R] is used.
.SH INCLUDE DIRECTIVE
.PP
The PgBouncer configuration file can contain include directives, which
specify another configuration file to read and process.
This allows splitting the configuration file into physically separate
parts.
The include directives look like this:
.IP
.nf
\f[C]
%include filename
\f[R]
.fi
.PP
If the file name is not an absolute path, it is taken as relative to the
current working directory.
.SH AUTHENTICATION FILE FORMAT
.PP
This section describes the format of the file specified by the
\f[C]auth_file\f[R] setting.
It is a text file in the following format:
.IP
.nf
\f[C]
\[dq]username1\[dq] \[dq]password\[dq] ...
\[dq]username2\[dq] \[dq]md5abcdef012342345\[dq] ...
\[dq]username2\[dq] \[dq]SCRAM\-SHA\-256$<iterations>:<salt>$<storedkey>:<serverkey>\[dq]
\f[R]
.fi
.PP
There should be at least 2 fields, surrounded by double quotes.
The first field is the user name and the second is either a plain\-text,
a MD5\-hashed password, or a SCRAM secret.
PgBouncer ignores the rest of the line.
Double quotes in a field value can be escaped by writing two double
quotes.
.PP
PostgreSQL MD5\-hashed password format:
.IP
.nf
\f[C]
\[dq]md5\[dq] + md5(password + username)
\f[R]
.fi
.PP
So user \f[C]admin\f[R] with password \f[C]1234\f[R] will have
MD5\-hashed password \f[C]md545f2603610af569b6155c45067268c6b\f[R].
.PP
PostgreSQL SCRAM secret format:
.IP
.nf
\f[C]
SCRAM\-SHA\-256$<iterations>:<salt>$<storedkey>:<serverkey>
\f[R]
.fi
.PP
See the PostgreSQL documentation and RFC 5803 for details on this.
.PP
The passwords or secrets stored in the authentication file serve two
purposes.
First, they are used to verify the passwords of incoming client
connections, if a password\-based authentication method is configured.
Second, they are used as the passwords for outgoing connections to the
backend server, if the backend server requires password\-based
authentication (unless the password is specified directly in the
database\[cq]s connection string).
The latter works if the password is stored in plain text or MD5\-hashed.
SCRAM secrets can only be used for logging into a server if the client
authentication also uses SCRAM, the PgBouncer database definition does
not specify a user name, and the SCRAM secrets are identical in
PgBouncer and the PostgreSQL server (same salt and iterations, not
merely the same password).
This is due to an inherent security property of SCRAM: The stored SCRAM
secret cannot by itself be used for deriving login credentials.
.PP
The authentication file can be written by hand, but it\[cq]s also useful
to generate it from some other list of users and passwords.
See \f[C]./etc/mkauth.py\f[R] for a sample script to generate the
authentication file from the \f[C]pg_shadow\f[R] system table.
Alternatively, use \f[C]auth_query\f[R] instead of \f[C]auth_file\f[R]
to avoid having to maintain a separate authentication file.
.SH HBA FILE FORMAT
.PP
The location of the HBA file is specified by the setting
\f[C]auth_hba_file\f[R].
It is only used if \f[C]auth_type\f[R] is set to \f[C]hba\f[R].
.PP
The file follows the format of the PostgreSQL \f[C]pg_hba.conf\f[R] file
(see <https://www.postgresql.org/docs/current/auth-pg-hba-conf.html>).
.IP \[bu] 2
Supported record types: \f[C]local\f[R], \f[C]host\f[R],
\f[C]hostssl\f[R], \f[C]hostnossl\f[R].
.IP \[bu] 2
Database field: Supports \f[C]all\f[R], \f[C]sameuser\f[R],
\f[C]\[at]file\f[R], multiple names.
Not supported: \f[C]replication\f[R], \f[C]samerole\f[R],
\f[C]samegroup\f[R].
.IP \[bu] 2
User name field: Supports \f[C]all\f[R], \f[C]\[at]file\f[R], multiple
names.
Not supported: \f[C]+groupname\f[R].
.IP \[bu] 2
Address field: Supports IPv4, IPv6.
Not supported: DNS names, domain prefixes.
.IP \[bu] 2
Auth\-method field: Only methods supported by PgBouncer\[cq]s
\f[C]auth_type\f[R] are supported, plus \f[C]peer\f[R] and
\f[C]reject\f[R], but except \f[C]any\f[R] and \f[C]pam\f[R], which only
work globally.
User name map (\f[C]map=\f[R]) parameter is not supported.
.SH EXAMPLES
.PP
Small example configuration:
.IP
.nf
\f[C]
[databases]
template1 = host=localhost dbname=template1 auth_user=someuser

[pgbouncer]
pool_mode = session
listen_port = 6432
listen_addr = localhost
auth_type = md5
auth_file = users.txt
logfile = pgbouncer.log
pidfile = pgbouncer.pid
admin_users = someuser
stats_users = stat_collector
\f[R]
.fi
.PP
Database examples:
.IP
.nf
\f[C]
[databases]

; foodb over Unix socket
foodb =

; redirect bardb to bazdb on localhost
bardb = host=localhost dbname=bazdb

; access to destination database will go with single user
forcedb = host=localhost port=300 user=baz password=foo client_encoding=UNICODE datestyle=ISO
\f[R]
.fi
.PP
Example of a secure function for \f[C]auth_query\f[R]:
.IP
.nf
\f[C]
CREATE OR REPLACE FUNCTION pgbouncer.user_lookup(in i_username text, out uname text, out phash text)
RETURNS record AS $$
BEGIN
    SELECT usename, passwd FROM pg_catalog.pg_shadow
    WHERE usename = i_username INTO uname, phash;
    RETURN;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
REVOKE ALL ON FUNCTION pgbouncer.user_lookup(text) FROM public, pgbouncer;
GRANT EXECUTE ON FUNCTION pgbouncer.user_lookup(text) TO pgbouncer;
\f[R]
.fi
.PP
Example configs for 2 peered PgBouncer processes to create a multi\-core
PgBouncer setup using \f[C]so_reuseport\f[R].
The config for the first process:
.IP
.nf
\f[C]
[databases]
postgres = host=localhost dbname=postgres

[peers]
1 = host=/tmp/pgbouncer1
2 = host=/tmp/pgbouncer2

[pgbouncer]
listen_addr=127.0.0.1
auth_file=auth_file.conf
so_reuseport=1
unix_socket_dir=/tmp/pgbouncer1
peer_id=1
\f[R]
.fi
.PP
The config for the second process:
.IP
.nf
\f[C]
[databases]
postgres = host=localhost dbname=postgres

[peers]
1 = host=/tmp/pgbouncer1
2 = host=/tmp/pgbouncer2

[pgbouncer]
listen_addr=127.0.0.1
auth_file=auth_file.conf
so_reuseport=1
; only unix_socket_dir and peer_id are different
unix_socket_dir=/tmp/pgbouncer2
peer_id=2
\f[R]
.fi
.SH SEE ALSO
.PP
pgbouncer(1) \- man page for general usage, console commands
.PP
<https://www.pgbouncer.org/>
